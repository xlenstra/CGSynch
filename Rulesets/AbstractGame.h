//
// Created by Xander Lenstra on 15-02-22.
//

#ifndef CGSYNCH_2_ABSTRACTGAME_H
#define CGSYNCH_2_ABSTRACTGAME_H

#include <concepts>

#include "CombinatorialGame/CombinatorialGameDatabase.h"
#include "GameDatabase.h"
#include "../Util/Matrix.h"
#include "RulesetUtil.h"
#include "SynchronousGame/SynchronizedGameDatabase.h"

template<isPosition Position, isGame<Position> Game>
AlternatingId getAlternatingId(Game& game);

/** An abstract class for combinatorial games
 * Each of these classes is a node in a tree, with the left options and right options saved in the class
 * This tree is not generated by default, but can be extended by calling [exploreAlternating()]
 * This class also references the ID of the abstract game that has the 'same' left and right options
 *
 * @param comparable A type that must be Position and hashable
 */
template<isPosition Position>
class AbstractGame {
public:

	/** Get the left and right options of this game */
	virtual std::vector<GameId> getLeftOptions();
	virtual std::vector<GameId> getRightOptions();

	virtual SynchedOptionData getSynchedOptions();

	/** Get a string of the position of this game */
	virtual std::string getDisplayString() { return ""; };

	/** Gets any transposition; used for checking if it is in the transposition table */
	virtual Position getAnyTransposition() const = 0;
	/** Get a set of all transpositions of this position; added to the transposition table */
	virtual std::unordered_set<Position> getTranspositions() const = 0;
//	virtual GameId getIdOrInsertIntoDatabase() = 0;
    /** Returns whether the left and right options of this position have been calculated yet */
	bool hasBeenExploredAlternating() { return alternatingExplored; }
	/** Determine the left and right options of this position. Does not recursively exploreAlternating its options */
	virtual void exploreAlternating() = 0;

	/** Returns whether the synchronized options of this position have been calculated yet */
	bool hasBeenExploredSynched() { return synchedExplored; }

	/** Determine the matrix of synchronized options of this position. Does not recursively exploreAlternating its options */
	virtual void exploreSynched() = 0;

	/** Returns the id of the abstract form of this game, or -1 if it has not been calculated yet */
	AlternatingId getAlternatingId() { return alternatingId; }
	/** Set the abstract form of this game */
	void setAlternatingId(AlternatingId id) { alternatingId = id; }
	/** Can be overriden to give an alternative way to calculate the abstract ID of a position.
	 *  If it returns false, the normal recursive exploration approach will be used.
	 *  If it returns true, that will be skipped. This function must then set <code>abstractForm</code> themselves.
	 *  Is automatically called in <code>getAlternatingId()</code>.
	 */
	virtual bool tryToDetermineAlternatingId() { return false; }

	SynchedId getSynchedId() { return synchedId; }
	void setSynchedId(SynchedId id) { synchedId = id; }
	virtual bool tryToDetermineSynchedId() { return false; }
	virtual bool determineDecidedSynchedValue() { return false; }

	/** Sets the ID of this game in the corresponding database */
	void setGameId(GameId id) { gameId = id; }

	GameId getGameId() const { return gameId; }

protected:
	AbstractGame() = default;

	bool alternatingExplored = false;
	bool synchedExplored = false;
	std::vector<GameId> leftOptions {};
	std::vector<GameId> rightOptions {};
	SynchedOptionData synchedOptions;
	GameId gameId = -1ul;
	AlternatingId alternatingId = -1;
	SynchedId synchedId = -1;
	std::string displayString;
};

// Templated class, so member functions need to go here

template<isPosition Position>
std::vector<GameId> AbstractGame<Position>::getLeftOptions() {
	if (!alternatingExplored) {
		exploreAlternating();
		alternatingExplored = true;
	}
	return leftOptions;
}

template<isPosition Position>
std::vector<GameId> AbstractGame<Position>::getRightOptions() {
	if (!alternatingExplored) {
		exploreAlternating();
		alternatingExplored = true;
	}
	return rightOptions;
}

template<typename Position>
SynchedOptionData AbstractGame<Position>::getSynchedOptions() {
	if (!synchedExplored) {
		exploreSynched();
		synchedExplored = true;
	}
	return synchedOptions;
}


template<isPosition Position, isGame<Position> Game>
AlternatingId getAlternatingId(Game& game) {
	if (game.getAlternatingId() != -1ul) return game.getAlternatingId();
	if (game.tryToDetermineAlternatingId()) return game.getAlternatingId();
	std::set<AlternatingId> leftOptions;
	std::set<AlternatingId> rightOptions;
	GameDatabase<Position, Game>& database = *GameDatabase<Position, Game>::getInstance();
	for (const auto& leftPosition : game.getLeftOptions()) {
		leftOptions.insert(getAlternatingId<Position, Game>(database.idToGame(leftPosition)));
	}
	for (const auto& rightPosition : game.getRightOptions()) {
		rightOptions.insert(getAlternatingId<Position, Game>(database.idToGame(rightPosition)));
	}
	game.setAlternatingId(CGDatabase::getInstance().getGameId(leftOptions, rightOptions));
	return game.getAlternatingId();
}

template<isPosition Position, isGame<Position> Game>
SynchedId getSynchedId(Game& game) {
	if (game.getSynchedId() != -1ul) return game.getSynchedId();
	if (game.tryToDetermineSynchedId()) return game.getSynchedId();
	SynchedOptionData synchedOptions = game.getSynchedOptions();
	if (synchedOptions.options.getHeight() * synchedOptions.options.getWidth() == 0) {
		if (!game.determineDecidedSynchedValue()) {
			throw std::logic_error("Could not determine value of a decided game.");
		}
		return game.getSynchedId();
	}
	SynchedMatrix synchedMatrix;
	synchedMatrix.matrix = Matrix(synchedOptions.options.getWidth(), synchedOptions.options.getHeight(), -1ul);
	GameDatabase<Position, Game>& database = *GameDatabase<Position, Game>::getInstance();
	for (size_t row = 0; row < synchedOptions.options.size(); ++row) {
		for (size_t column = 0; column < synchedOptions.options[row].size(); ++column) {
			auto id = getSynchedId<Position, Game>(database.idToGame(synchedOptions.options[row][column]));
			synchedMatrix.matrix[row][column] = id;
		}
	}
	for (const auto& leftPosition : game.getLeftOptions()) {
		synchedMatrix.leftOptions.push_back(getSynchedId<Position, Game>(database.idToGame(leftPosition)));
	}
	for (const auto& rightPosition : game.getRightOptions()) {
		synchedMatrix.rightOptions.push_back(getSynchedId<Position, Game>(database.idToGame(rightPosition)));
	}
	game.setSynchedId(SGDatabase::getInstance().getGameId(synchedMatrix));
	return game.getSynchedId();
}

#define CreateDatabase(PositionName, GameName, databaseName)                                                                   \
	/* Initialize static member variables */                                                                                   \
	template<> std::shared_ptr<GameDatabase<PositionName, GameName>> GameDatabase<PositionName, GameName>::instance = nullptr; \
    template<> std::vector<std::shared_ptr<GameName>> GameDatabase<PositionName, GameName>::database = {};                     \
    template<> std::unordered_map<PositionName, GameId> GameDatabase<PositionName, GameName>::transpositionTable = {};         \
    /* Get a global variable for the actual database. Should probably be inlined */                                            \
    const std::shared_ptr<GameDatabase<PositionName, GameName>> databaseName = GameDatabase<PositionName, GameName>::getInstance();



#endif //CGSYNCH_2_ABSTRACTGAME_H
