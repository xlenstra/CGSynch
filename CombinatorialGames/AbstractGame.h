//
// Created by ardour on 15-02-22.
//

#ifndef CGSYNCH_2_ABSTRACTGAME_H
#define CGSYNCH_2_ABSTRACTGAME_H

#include <concepts>
#include "RulesetUtil.h"
#include "CombinatorialGame/CombinatorialGameDatabase.h"
#include "GameDatabase.h"

template<isPosition Position, isGame<Position> Game>
AbstractId getAbstractFormId(Game& game);

/** An abstract class for combinatorial games
 * Each of these classes is a node in a tree, with the left options and right options saved in the class
 * This tree is not generated by default, but can be extended by calling [explore()]
 * This class also references the ID of the abstract game that has the 'same' left and right options
 *
 * @param comparable A type that must be Position and hashable
 */
template<isPosition Position>
class AbstractGame {
public:

	/** Get the left and right options of this game */
	virtual std::unordered_set<GameId> getLeftOptions();
	virtual std::unordered_set<GameId> getRightOptions();

	/** Get a string of the position of this game */
	virtual std::string getDisplayString() = 0;

	/** Gets any transposition; used for checking if it is in the transposition table */
	virtual Position getAnyTransposition() const = 0;
	/** Get a set of all transpositions of this position; added to the transposition table */
	virtual std::unordered_set<Position> getTranspositions() const = 0;
//	virtual GameId getIdOrInsertIntoDatabase() = 0;
    /** Returns whether the left and right options of this position have been calculated yet */
	bool hasBeenExplored() { return explored; }
	/** Determine the left and right options of this position. Does not recursively explore its options */
	virtual void explore() = 0;

	/** Returns the id of the abstract form of this game, or -1 if it has not been calculated yet */
	AbstractId getAbstractForm() { return abstractForm; }
	/** Set the abstract form of this game */
	virtual void setAbstractForm(AbstractId id) { abstractForm = id; }
	/** Can be overriden to give an alternative way to calculate the abstract ID of a position.
	 *  If it returns false, the normal recursive exploration approach will be used.
	 *  If it returns true, that will be skipped. This function must then set <code>abstractForm</code> themselves.
	 *  Is automatically called in <code>getAbstractFormId()</code>.
	 */
	virtual bool tryToDetermineAbstractForm() { return false; }

	/** Sets the ID of this game in the corresponding database */
	void setId(GameId id) { rulesetId = id; }

	GameId getId() const { return rulesetId; }

	//virtual void determineAbstractForm() { getAbstractFormId<Position, AbstractGame>(this); }

protected:
	AbstractGame() = default;

	bool explored = false;
	std::unordered_set<GameId> leftOptions {};
	std::unordered_set<GameId> rightOptions {};
	GameId rulesetId = -1ul;
	AbstractId abstractForm = -1;
	std::string displayString;
};



// Templated class, so member functions need to go here

template<isPosition comparable>
std::unordered_set<GameId> AbstractGame<comparable>::getLeftOptions() {
	if (!explored) explore();
	return leftOptions;
}

template<isPosition comparable>
std::unordered_set<GameId> AbstractGame<comparable>::getRightOptions() {
	if (!explored) explore();
	return rightOptions;
}

template<isPosition Position, isGame<Position> Game>
AbstractId getAbstractFormId(Game& game) {
	if (game.getAbstractForm() != -1ul) return game.getAbstractForm();
	if (game.tryToDetermineAbstractForm()) return game.getAbstractForm();
	std::unordered_set<AbstractId> leftOptions;
	std::unordered_set<AbstractId> rightOptions;
	GameDatabase<Position, Game>& database = *GameDatabase<Position, Game>::getInstance();
	for (const auto& leftPosition : game.getLeftOptions()) {
		leftOptions.insert(getAbstractFormId<Position, Game>(database.idToGame(leftPosition)));
	}
	for (const auto& rightPosition : game.getRightOptions()) {
		rightOptions.insert(getAbstractFormId<Position, Game>(database.idToGame(rightPosition)));
	}
	game.setAbstractForm(CGDatabase::getInstance().getGameId(leftOptions, rightOptions));
	return game.getAbstractForm();
}


#endif //CGSYNCH_2_ABSTRACTGAME_H
